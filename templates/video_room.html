<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{ room_title }} - Video Room</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #0f172a; color: #e2e8f0; }
    .topbar { padding: 12px 16px; background: #1e293b; display: flex; justify-content: space-between; align-items: center; gap: 12px; }
    .topbar h3 { margin: 0; font-size: 18px; }
    .meta { font-size: 13px; color: #94a3b8; }
    .actions { display: flex; gap: 10px; }
    button { border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; }
    .btn { background: #334155; color: #fff; }
    .btn-danger { background: #dc2626; color: #fff; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 12px; padding: 12px; }
    .tile { background: #111827; border: 1px solid #1f2937; border-radius: 10px; overflow: hidden; }
    .tile video { width: 100%; height: 200px; background: #000; object-fit: cover; }
    .tile .name { padding: 8px 10px; font-size: 13px; color: #cbd5e1; }
    .status { padding: 8px 12px; font-size: 13px; color: #94a3b8; }
  </style>
</head>
<body>
  <div class="topbar">
    <div>
      <h3>{{ room_title }}</h3>
      <div class="meta">Room: {{ room_code }} | You: {{ user_name }} ({{ role }})</div>
    </div>
    <div class="actions">
      <button class="btn" id="toggleMic">Mute</button>
      <button class="btn" id="toggleCam">Stop Video</button>
      <button class="btn-danger" id="leaveBtn">Leave</button>
    </div>
  </div>

  <div class="status" id="status">Initializing camera and microphone...</div>
  <div class="grid" id="videoGrid"></div>

  <script>
    const roomCode = {{ room_code|tojson }};
    const displayName = {{ user_name|tojson }};
    const peerId = `peer-${Math.random().toString(36).slice(2, 10)}-${Date.now()}`;
    const pollingMs = 900;

    const videoGrid = document.getElementById('videoGrid');
    const statusEl = document.getElementById('status');
    const toggleMicBtn = document.getElementById('toggleMic');
    const toggleCamBtn = document.getElementById('toggleCam');
    const leaveBtn = document.getElementById('leaveBtn');

    let localStream = null;
    let pollTimer = null;
    const peers = new Map();
    const remoteStreams = new Map();
    const peerNames = new Map();
    const pendingPlay = new Set();
    const isSecureContextOk = window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';

    function setStatus(msg) { statusEl.textContent = msg; }
    function appendStatus(msg) { statusEl.textContent = `${statusEl.textContent} ${msg}`; }

    function describeMediaError(err) {
      if (!err) return 'Unknown media error.';
      if (err.name === 'NotAllowedError') return 'Permission denied. Allow camera and microphone in browser site settings.';
      if (err.name === 'NotFoundError') return 'No camera/microphone detected on this device.';
      if (err.name === 'NotReadableError') return 'Camera/microphone is busy in another app/tab.';
      if (err.name === 'SecurityError') return 'Blocked by browser security policy. Use HTTPS.';
      if (err.name === 'OverconstrainedError') return 'Requested camera settings are not supported.';
      return `${err.name || 'Error'}: ${err.message || 'media access failed'}`;
    }

    function addVideoTile(id, stream, name, muted = false) {
      let tile = document.getElementById(`tile-${id}`);
      if (!tile) {
        tile = document.createElement('div');
        tile.id = `tile-${id}`;
        tile.className = 'tile';
        tile.innerHTML = `<video autoplay playsinline></video><div class="name"></div>`;
        videoGrid.appendChild(tile);
      }
      const video = tile.querySelector('video');
      video.srcObject = stream;
      video.muted = muted;
      tile.querySelector('.name').textContent = name || id;
      const p = video.play();
      if (p && typeof p.catch === 'function') {
        p.catch(() => pendingPlay.add(video));
      }
    }

    function removeVideoTile(id) {
      const tile = document.getElementById(`tile-${id}`);
      if (tile) tile.remove();
    }

    function createPeerConnection(remotePeerId, remoteName) {
      if (peers.has(remotePeerId)) return peers.get(remotePeerId);
      if (remoteName) {
        peerNames.set(remotePeerId, remoteName);
      }

      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          sendSignal(remotePeerId, 'candidate', event.candidate);
        }
      };

      pc.ontrack = (event) => {
        let stream = remoteStreams.get(remotePeerId);
        if (!stream) {
          stream = new MediaStream();
          remoteStreams.set(remotePeerId, stream);
        }
        stream.addTrack(event.track);
        const label = peerNames.get(remotePeerId) || remoteName || remotePeerId;
        addVideoTile(remotePeerId, stream, label, false);
      };

      peers.set(remotePeerId, { pc, name: remoteName || remotePeerId });
      return peers.get(remotePeerId);
    }

    async function sendSignal(toPeer, type, payload) {
      await fetch(`/api/video/${roomCode}/signal`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ to_peer: toPeer, from_peer: peerId, type, payload })
      });
    }

    async function connectToPeer(remotePeerId, remoteName) {
      const info = createPeerConnection(remotePeerId, remoteName);
      const offer = await info.pc.createOffer();
      await info.pc.setLocalDescription(offer);
      await sendSignal(remotePeerId, 'offer', offer);
    }

    async function handleSignal(message) {
      const type = message.type;
      const fromPeer = message.from_peer;

      if (type === 'peer-joined') {
        if (message.name) {
          peerNames.set(fromPeer, message.name);
        }
        // Avoid offer glare: only the newly joined client sends offers (from /join peers list).
        setStatus('Participant joined.');
        return;
      }

      if (type === 'peer-left') {
        const peer = peers.get(fromPeer);
        if (peer) {
          peer.pc.close();
          peers.delete(fromPeer);
        }
        remoteStreams.delete(fromPeer);
        removeVideoTile(fromPeer);
        setStatus('Participant left.');
        return;
      }

      if (type === 'offer') {
        const resolvedName = peerNames.get(fromPeer) || message.name || fromPeer;
        peerNames.set(fromPeer, resolvedName);
        const peer = createPeerConnection(fromPeer, resolvedName);
        await peer.pc.setRemoteDescription(new RTCSessionDescription(message.payload));
        const answer = await peer.pc.createAnswer();
        await peer.pc.setLocalDescription(answer);
        await sendSignal(fromPeer, 'answer', answer);
        return;
      }

      if (type === 'answer') {
        const peer = peers.get(fromPeer);
        if (peer) {
          await peer.pc.setRemoteDescription(new RTCSessionDescription(message.payload));
        }
        return;
      }

      if (type === 'candidate') {
        const peer = peers.get(fromPeer);
        if (peer && message.payload) {
          try {
            await peer.pc.addIceCandidate(new RTCIceCandidate(message.payload));
          } catch (e) {}
        }
      }
    }

    async function pollSignals() {
      try {
        const res = await fetch(`/api/video/${roomCode}/poll/${peerId}`);
        const data = await res.json();
        if (data.success && Array.isArray(data.messages)) {
          for (const msg of data.messages) {
            await handleSignal(msg);
          }
        }
      } catch (err) {}
    }

    async function joinRoom() {
      const res = await fetch(`/api/video/${roomCode}/join`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ peer_id: peerId, name: displayName })
      });
      const data = await res.json();
      if (!data.success) throw new Error(data.message || 'Join failed');

      for (const p of data.peers || []) {
        if (p.name) {
          peerNames.set(p.peer_id, p.name);
        }
        await connectToPeer(p.peer_id, p.name);
      }

      pollTimer = setInterval(pollSignals, pollingMs);
      const total = (data.peers || []).length + 1;
      if (total > 1) {
        setStatus(`Connected. ${total} participants in room.`);
      } else {
        setStatus('Connected. Waiting for participants...');
      }
    }

    async function getLocalMediaWithFallback() {
      const attempts = [
        {
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        },
        { video: true, audio: true },
        { video: true, audio: false },
        { video: false, audio: true }
      ];

      let lastErr = null;
      for (const constraints of attempts) {
        try {
          return await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr;
    }

    async function leaveRoom() {
      if (pollTimer) clearInterval(pollTimer);
      try {
        await fetch(`/api/video/${roomCode}/leave`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ peer_id: peerId })
        });
      } catch (e) {}

      peers.forEach((v) => v.pc.close());
      peers.clear();
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
      }
      window.history.back();
    }

    toggleMicBtn.addEventListener('click', () => {
      if (!localStream) return;
      const audioTrack = localStream.getAudioTracks()[0];
      if (!audioTrack) return;
      audioTrack.enabled = !audioTrack.enabled;
      toggleMicBtn.textContent = audioTrack.enabled ? 'Mute' : 'Unmute';
    });

    toggleCamBtn.addEventListener('click', () => {
      if (!localStream) return;
      const videoTrack = localStream.getVideoTracks()[0];
      if (!videoTrack) return;
      videoTrack.enabled = !videoTrack.enabled;
      toggleCamBtn.textContent = videoTrack.enabled ? 'Stop Video' : 'Start Video';
    });

    leaveBtn.addEventListener('click', leaveRoom);
    window.addEventListener('beforeunload', () => { navigator.sendBeacon(`/api/video/${roomCode}/leave`, new Blob([JSON.stringify({ peer_id: peerId })], { type: 'application/json' })); });
    document.addEventListener('click', () => {
      pendingPlay.forEach((video) => {
        const p = video.play();
        if (p && typeof p.then === 'function') {
          p.then(() => pendingPlay.delete(video)).catch(() => {});
        } else {
          pendingPlay.delete(video);
        }
      });
    });

    (async function init() {
      try {
        if (!isSecureContextOk) {
          setStatus('Camera/mic requires HTTPS. Open this room over https://');
          return;
        }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          setStatus('This browser does not support camera/microphone capture.');
          return;
        }

        localStream = await getLocalMediaWithFallback();
        const audioTracks = localStream.getAudioTracks();
        const videoTracks = localStream.getVideoTracks();
        if (!audioTracks.length || !videoTracks.length) {
          appendStatus(`(Limited devices: audio ${audioTracks.length ? 'ok' : 'missing'}, video ${videoTracks.length ? 'ok' : 'missing'})`);
        }
        if (!videoTracks.length) {
          setStatus('Camera unavailable. Joined with microphone only.');
        }
        if (!audioTracks.length) {
          setStatus('Microphone unavailable. Joined with camera only.');
        }

        addVideoTile(peerId, localStream, `${displayName} (You)`, true);
        await joinRoom();
      } catch (e) {
        setStatus(describeMediaError(e));
      }
    })();
  </script>
</body>
</html>
